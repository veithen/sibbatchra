package ra;

import java.io.Serializable;
import java.util.HashMap;
import java.util.Map;

import javax.resource.spi.ActivationSpec;
import javax.resource.spi.ResourceAdapter;
import javax.resource.spi.endpoint.MessageEndpoint;
import javax.transaction.Transaction;
import javax.transaction.xa.XAResource;

import com.ibm.tx.jta.ExtendedTransactionManager;
import com.ibm.tx.jta.XAResourceFactory;
import com.ibm.websphere.sib.exception.SIException;
import com.ibm.websphere.sib.exception.SIIncorrectCallException;
import com.ibm.websphere.sib.exception.SIResourceException;
import com.ibm.ws.Transaction.WebSphereTransactionManager;
import com.ibm.ws.Transaction.XAResourceInfo;
import com.ibm.wsspi.sib.core.SICoreConnection;
import com.ibm.wsspi.sib.core.SICoreConnectionFactory;
import com.ibm.wsspi.sib.core.exception.SIInsufficientDataForFactoryTypeException;
import com.ibm.wsspi.sib.core.selector.FactoryType;
import com.ibm.wsspi.sib.core.selector.SICoreConnectionFactorySelector;

/**
 * {@link XAResourceInfo} implementation for the SIB batch inbound connector. On WebSphere, an
 * attempt to enlist a 2PC resource with {@link Transaction#enlistResource(XAResource)} fails with
 * an "Illegal attempt to enlist a 2PC XA Resource" error. The reason seams to be that WebSphere
 * only allows enlisting 2PC resources with a recovery token. There are several ways how this
 * recovery token can be provided:
 * <ol>
 * <li>The recovery token is obtained from
 * {@link ExtendedTransactionManager#registerResourceInfo(String, Serializable)} and then passed to
 * {@link ExtendedTransactionManager#enlist(XAResource, int)}.
 * <li>The recovery token is implicitly generated by a call to
 * {@link WebSphereTransactionManager#enlist(XAResource, String, XAResourceInfo)}.
 * </ol>
 * In both cases, an implementation of {@link XAResourceInfo} and {@link XAResourceFactory} is
 * required.
 * <p>
 * Note that all this is only required because the resource adapter manages transactions itself (so
 * that we can deliver multiple messages in a single transaction). For transactions managed by
 * {@link MessageEndpoint} WebSphere takes care of setting up the recovery (presumably relying on
 * {@link ResourceAdapter#getXAResources(ActivationSpec[])}).
 */
public class SibBatchResourceInfo implements XAResourceInfo {
    private static final long serialVersionUID = 1L;
    
    private final String busName;
    
    public SibBatchResourceInfo(String busName) {
        this.busName = busName;
    }

    public SICoreConnection createConnection() throws SIException {
        SICoreConnectionFactory factory = SICoreConnectionFactorySelector.getSICoreConnectionFactory(FactoryType.TRM_CONNECTION);
        Map properties = new HashMap();
        properties.put("busName", busName);
        // TODO: other properties: targetType, targetGroup, targetSignificance, targetTransportChain, providerEndpoints
        
        // TODO: security not supported
        return factory.createConnection(null, null, properties);
    }
    
    public String getRMName() {
        // The RMName is displayed in the admin console when inspecting a transaction. Therefore
        // we need to generate a human readable name that allows the user to identify the resource.
        return "SIBusBatch:" + busName;
    }

    public boolean commitInLastPhase() {
        return false;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((busName == null) ? 0 : busName.hashCode());
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        SibBatchResourceInfo other = (SibBatchResourceInfo) obj;
        if (busName == null) {
            if (other.busName != null)
                return false;
        } else if (!busName.equals(other.busName))
            return false;
        return true;
    }
}
